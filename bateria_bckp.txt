#include <stdio.h>      // entrada e saída básica (printf, etc.)
#include <windows.h>    // para WAVEFORMATEX, HWAVEOUT, Sleep, etc.
#include <mmsystem.h>   // para waveOutOpen, waveOutWrite, etc.
#include <conio.h>      // para _kbhit() e _getch() (leitura de teclado em tempo real)
#include <math.h>

int main(){
    #define BUFFER_SIZE (44100 / 20)
    #ifndef M_PI
    #define M_PI 3.14159265358979323846
    #endif

    WAVEFORMATEX wfx;
    wfx.wFormatTag = WAVE_FORMAT_PCM;   // som simples (PCM)
    wfx.nChannels = 1;                  // 1 = mono
    wfx.nSamplesPerSec = 44100;          // 8000 amostras por segundo
    wfx.wBitsPerSample = 16;             // cada amostra = 1 byte
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
    wfx.cbSize = 0;

    HWAVEOUT hWave;
    waveOutOpen(&hWave, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);

    while(1){
        int freq = 0;
        float decay;
        float duration;

        if(_kbhit()){
            char tecla = _getch();

            if(tecla == 27) break;

            switch (tecla){
                case 'g': //bumbo
                    freq = 60;
                    decay = 0.0008;
                    duration = 44100.0 * 0.3;
                    break; 
                case 'f': //snare
                    freq = 180;
                    decay = 0.005;
                    duration = 44100.0 * 0.15;
                    break; 
                case 'h': // hihat
                    freq = 10000; 
                    decay = 0.02;
                    duration = 44100.0 * 0.1;
                    break; 
                case 't': //tomg
                    freq = 200; 
                    decay = 0.0015;
                    duration = 44100.0 * 0.25;
                    break; 
                default: freq = 0; break;
            }
            short buffer[BUFFER_SIZE];
            int samples_per_period = 44100 / freq;
            double amplitude;

            // switch(tecla){
            //     case 'g':
            //         for (int i = 0; i < BUFFER_SIZE; i++) {
            //             double t = (double)i / 44100.0;
            //             double amplitude = sin(2 * M_PI * freq * i / 44100) * ( exp(-decay * i));
            //             buffer[i] = (short)(amplitude * 30000);
            //         }
            //         break;
            // }

            for (int i = 0; i < BUFFER_SIZE; i++) {
                double t = (double)i / duration;
                double phase = 2 * M_PI * freq * i / 44100;
                if(tecla == 'h'){
                    amplitude = ((rand() % 2000) - 1000) / 1000.0 * exp(-decay * i);
                }
                else{
                    amplitude = sin(phase) * exp(-decay * i);
                }
                buffer[i] = (short)(amplitude * 30000);
            }
            while(freq > 0){
                WAVEHDR header;
                memset(&header, 0, sizeof(WAVEHDR)); 
                header.lpData = (LPSTR)buffer;
                header.dwBufferLength = BUFFER_SIZE;
                header.dwFlags = 0;
                header.dwLoops = 0;
                waveOutPrepareHeader(hWave, &header, sizeof(WAVEHDR));
                waveOutWrite(hWave, &header, sizeof(WAVEHDR));
                while (waveOutUnprepareHeader(hWave, &header, sizeof(WAVEHDR)) == WAVERR_STILLPLAYING) {
                    Sleep(5);
                }
                //Sleep(BUFFER_SIZE * 1000 / 44100);
                freq = 0;
                memset(buffer, 0, sizeof(buffer)); 
                }    
            }     
            
        }
        
}
